
/** 
 * SplineFactory class written using the revealing module pattern 
 * makes splines to spell words in smoke trails
 */
var SplineFactory = function(){

	// Distance between letters
	var ledding = 20;

	var charDefs = {
		a: [
			[   0,   0,   0 ],
			[  75,  10,   0 ],
			[ 170,  50,   0 ],
			[ 170, 150,   0 ],
			[ 100, 190,   0 ],
			[  30, 150,   0 ],
			[  50,  30,   0 ],
			[ 170,  40,   0 ],
			[ 170, 170,  50 ],
			[ 170, 140,  20 ],
			[ 170,  70,   0 ],
			[ 200,   0,   0 ]
		],
		b: [
			[   0,   0,   0 ],
			[  15,  40,   0 ],
			[  15, 260,   0 ],
			[  15, 250, -50 ],
			[  15, 190, -50 ],
			[  30,  40,   0 ],
			[  70,  30,   0 ],
			[  110, 120,   0 ],
			[  80, 180,   0 ],
			[  15, 140,   0 ],
			[  15,  70,   0 ],
			[  70,  10,   0 ],
			[  90,  10,   0 ]
		],
		c: [
			[   0,   0,   0 ],
			[  15,  40,   0 ],
			[  15, 160,   0 ],
			[  90, 170,   0 ],
			[  15, 190,   0 ],
			[  30,  40,   0 ],
			[  70,  30,   0 ],
			[  90,  50,   0 ],
			[  90,  50, -50 ],
			[  70,  30, -20 ],
			[  90,   0,   0 ]
		],
		test: [
			[   0,   0,   0 ],
			[   0, 200,   0 ],
			[ 140, 150,   0 ],
			[ 120,  50,  70 ],
			[  60,  60, 140 ],
			[  70, 150, 120 ],
			[  75, 150,  20 ],
			[ 250, 100,  20 ],
			[ 250, 300, -30 ]
		]
	};


	/** 
	 * Gets the vectors to create a spline in the shape of a letter
	 *
	 * @param {string} key
	 * @param {integer} xOffset
	 *
	 * @return {array} Contains {array} vectors, {number} width 
	 */
	function getCharVectors( key, xOffset ){
		var item,
			vectors = [],
			width = 0;

		for( var i in charDefs[key] ){
			item = charDefs[key][i];
			if( item[0] > width ){
				width = item[0];
			}
			vectors = vectors.concat( new THREE.Vector3( item[0] + xOffset, item[1], item[2] ) );
		}

		return { 
			width: width, 
			vectors: vectors 
		};
	}


	/** 
	 * Returns a spline that spells out a word
	 *
	 * @param {string} word The word to spell out with the vector points
	 *
	 * @return {THREE.CatmullRomCurve3} The spline
	 */
	var word = function( word ){
	  var vectors = [],
	    offset = -100,
	    vectorsResult;

	  for( var i = 0, iLimit = word.length; i < iLimit; i++ ){

	    vectorsResult = getCharVectors( word[i], offset );

	    // Increment the offset for the next iteration
	    offset += vectorsResult.width + ledding;
	    vectors = vectors.concat( vectorsResult.vectors );
	  }

	  return new THREE.CatmullRomCurve3( vectors );
	}


	/** Revealing only the word method */
	return {
		word: word
	}
};

var splineFactory = new SplineFactory();


/**
 * A SmokeTrail has many SmokeBubbles
 */
var SmokeTrail = function(){
    var smokeBubbles = [];


    // Decay and/or remove the smoke bubbles
    function age() {

        // Iterate over the smokeBubbles aging them
        var i = smokeBubbles.length;
        while( i-- ){
          
            if( smokeBubbles[i].beOlder() <= 0 ){
                scene.remove( smokeBubbles[i].mesh );
                smokeBubbles.splice( i, 1 );
            }
          
        }

    };



    /**
     * Method on SmokeTrail class: Adds a smoke bubble to the trail
     *
     * @param position
     */
    function add() {
        smokeBubbles.push( new SmokeBubble( this, plane.box.position.x, plane.box.position.y, plane.box.position.z ) );
    };

    return {
        smokeBubbles: smokeBubbles,
        age: age,
        add: add
    }
};



/**
 * SmokeBubble class
 *
 * @param position
 */
var SmokeBubble = function( parent, x, y, z ){

    this.parent = parent;
    this.age = 0;
    this.scale = 0.1;

    this.originX = x;
    this.x = x;
    this.xDrift = Math.random() - 0.5;

    this.originY = y;
    this.y = y;
    this.yDrift = Math.random() - 0.5;

    // Define geometry and material for visualising the cuboid thing that'll travel along the line
    var geometry = new THREE.SphereGeometry( 8, 20 );
    var material = new THREE.MeshLambertMaterial( { color: 0xEEEEEE } );

    this.mesh = new THREE.Mesh(geometry, material);
    this.mesh.position.set(x, y, z);
    this.mesh.scale.x = this.scale;
    this.mesh.scale.y = this.scale;
    this.mesh.scale.z = this.scale;

    scene.add(this.mesh);
};


/**
 * Method on SmokeBubble class: Ages the bubble
 */
SmokeBubble.prototype.beOlder = function(){
    this.age++;

    // For the first 50 units grow
    if( this.age < 50 ){
        this.scale += 0.02;
    }

    // After age 80, shrink
    if( this.age > 80 ){
        this.scale -= 0.01;
    }

    if( Math.abs( this.originX - this.x ) < 1 ){
        this.x  += this.xDrift;
        this.mesh.position.x = this.x;
    }

    if( Math.abs( this.originY - this.y ) < 1 ){
        this.y  += this.yDrift;
        this.mesh.position.y = this.y;
    }

    this.mesh.scale.x = this.scale;
    this.mesh.scale.y = this.scale;
    this.mesh.scale.z = this.scale;

    return this.scale;
};




/**
 * A Plane
 */
var Plane = function(){

    var speed = 0.004;

    var smokeTrail = new SmokeTrail();

    /** {boolean} Indicates if the smoker is operational */
    var smoking = false;

    // Audio
    var smokeNoise = audioCtx.createBrownNoise();
    var gainNode = audioCtx.createGain();
    smokeNoise.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    gainNode.gain.value = 0;

    // Material for plane panels
    var material = new THREE.MeshLambertMaterial( { color: 0xFFFFFF } );

    var box = new THREE.Group();
    scene.add(box);

    // The fuselage 
    var fuselage_geometry = new THREE.BoxGeometry(3, 8, 3);
    var fuselage = new THREE.Mesh(fuselage_geometry, material);
    box.add(fuselage);

    // Cockpit 
    var fuselage_geometry = new THREE.BoxGeometry(3, 4, 3);
    var fuselage = new THREE.Mesh(fuselage_geometry, material);
    fuselage.translateZ(1.5);
    box.add(fuselage);

    // Wing
    var wing_geometry = new THREE.BoxGeometry(20, 4, 0.5);
    var wing = new THREE.Mesh(wing_geometry, material);
    wing.translateZ(3);
    box.add(wing);

    // Tail
    var tail_shape = new THREE.Shape();
    tail_shape.moveTo(0, 2);
    tail_shape.lineTo(0, 2.5);
    tail_shape.lineTo(8, 1.5);
    tail_shape.lineTo(8, -1.4);
    tail_shape.lineTo(0, 2);
    var extrudeSettings = {
      steps: 2,
      amount: 3,
      bevelEnabled: false
    }
    var tail_geometry = new THREE.ExtrudeGeometry(tail_shape, extrudeSettings);
    var tail = new THREE.Mesh(tail_geometry, material);
    tail.rotateY( Math.PI / 2);
    tail.rotateZ( Math.PI / 2);
    tail.translateX( -12);
    tail.translateZ( -1.5);
    box.add(tail);

    // Tail fin
    var tailFin_geometry = new THREE.BoxGeometry(0.4, 3, 3);
    var tailFin = new THREE.Mesh(tailFin_geometry, material);
    tailFin.translateY(-11);
    tailFin.translateZ(3.2);
    box.add(tailFin);

    // Nose cone
    var nose_geometry = new THREE.CylinderGeometry( 1.2, 1.8, 2.6, 20 );
    var nose = new THREE.Mesh(nose_geometry, material);
    nose.position.set( 0, 5.2, 0);
    box.add( nose );

    // Propeller
    var propeller_geometry = new THREE.CylinderGeometry( 3, 3, 0.2, 20 );
    var propeller_material = new THREE.MeshLambertMaterial( { color: 0xFFFFFF, transparent: true, opacity: 0.5 } );
    var scoutBox = new THREE.Mesh(propeller_geometry, propeller_material);
    scoutBox.position.set( 0, 7.2, 0);
    box.add( scoutBox );

    function setPosition(point) {
        box.position.copy(point);
        if( smoking ){
            smokeTrail.add();
        }
    }

    function setTangent(tangent) {

        axis.crossVectors(up, tangent).normalize();
        var radians = Math.acos(up.dot(tangent));

        // Pitch where:
        // -0.5 is flying directly upwards
        //  0.0 is cruising perfectly level 
        //  0.5 is plummeting towards the earth
        var pitch = 0.5 - ( Math.abs( Math.PI - radians ) ) / Math.PI;

        // Set gravity boost to some value between 0.9 - 1.1
        gravityBoost = 1 + (pitch/5);

        // Set the plane's rotation based on spline
        box.quaternion.setFromAxisAngle(axis, radians);
    }

    function toggleSmoke() {
        if( smoking ){
            return stopSmoke();
        }
        return startSmoke();
    }

    function startSmoke() {
        gainNode.gain.value = 0.02;
        return smoking = true;
    }

    function stopSmoke() {
        gainNode.gain.value = 0;
        return smoking = false;
    }

    return {
        speed: speed,
        box: box,
        smokeTrail: smokeTrail,
        setPosition: setPosition,
        setTangent: setTangent,
        toggleSmoke: toggleSmoke,
        startSmoke: startSmoke,
        stopSmoke: stopSmoke
    }
};


/**
 * 
 */
function fetchWord(){

  microAjax("/word/6/sausage", function(data){ 

    data = JSON.parse(data);

    console.log( data.word );

    updateLineToWord( data.word );

  });
}




/**
 * Produces a geometry object based on a word
 *
 * @param {string} word
 *
 * @return {THREE.Geometry}
 */
function getWordGeometry( word ){
  // Create a spline that spells the word
  spline = splineFactory.word( word );

  // Get 50 points back from the spline
  var numPoints = 60;
  var splinePoints = spline.getPoints(numPoints);

  // Define geometry for visualising the spline
  var geometry = new THREE.Geometry();
  for (var i = 0; i < splinePoints.length; i++) {
    geometry.vertices.push(splinePoints[i]);
  }

  return geometry;
}




/**
 * Changes the spline that the plane is following
 *
 * @param {string} word
 */
function updateLineToWord( word ){
  var line = scene.getObjectByName( "Word" );
  line.geometry = getWordGeometry( word );
}


var Sounds = function(){

    // Contributors to GitHub issue ticket 2 put your code here

    return {

    }

}

var sounds = new Sounds();

"use strict";



/** Global variables */
var controls, 
    renderer,
    scene, 
    camera, 
    spline,
    plane,
    gravityBoost = 0, 

    // Counter is a percentage as a decimal in range 0.0 - 1.0
    counter = 0,

    tangent = new THREE.Vector3(),
    axis = new THREE.Vector3(),
    up = new THREE.Vector3( 0, 1, 0),

    audioCtx = new AudioContext();



function movePlane() {
    movePlaneAlongSpline();
}


/** 
 * Increments the plane along a spline 
 */
function movePlaneAlongSpline() {

    plane.speed = plane.speed * gravityBoost;
    if( plane.speed < 0.001 ){
        plane.speed = 0.001;
    }
    if( plane.speed > 0.002 ){
        plane.speed = 0.002;
    }

    plane.smokeTrail.age();

    // Increment counter
    counter += plane.speed;

    // Make sure it doesn't go above 1
    if (counter > 1) {
        counter = 0;
    } 

    // Set the plane's position in the world based on the spline
    plane.setPosition( spline.getPointAt(counter) );

    // The direction the plane is heading
    tangent = spline.getTangentAt(counter).normalize();

    plane.setTangent(tangent);
}          




/** Render loop */
function render() {
    requestAnimationFrame(render);
    //controls.update();
    renderer.render(scene, camera);
} 




/** Initialise the scene */
(function() {

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene = new THREE.Scene();
    scene.name = 'Skywriter';

    // Add a camera 
    camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 1, 5000);
    camera.name = "Only Camera";
    camera.position.set(120, 120, 390);
    camera.lookAt(new THREE.Vector3(125, 140, 0));
    scene.add(camera);


    // LIGHTS
    scene.add( new THREE.DirectionalLight( 0xFFFFFF, 0.5 ) );
    scene.add( new THREE.AmbientLight( 0xFFFFFF, 0.5 ) );




    // TGA texture cube map -------------------------------------------------
    // Following code is a rehash of CubeTextureLoader but made to work with TGA files
    // https://github.com/mrdoob/three.js/blob/master/src/loaders/CubeTextureLoader.js
    // I could repackage it as a module and submit pull request to ThreeJS

    var path = "ame_desert/desertsky_";
    var format = '.tga';
    var urls = [
        path + 'ft' + format, path + 'bk' + format,
        path + 'up' + format, path + 'dn' + format, 
        path + 'rt' + format, path + 'lf' + format
    ];

    var texture = new THREE.CubeTexture();

    var loader = new THREE.TGALoader();
    //loader.setCrossOrigin( this.crossOrigin );
    //loader.setPath( this.path );

    var loaded = 0;

    function loadTexture( i ) {

        loader.load( urls[ i ], function ( image ) {

            texture.images[ i ] = image.image;

            loaded ++;

            if ( loaded === 6 ) {

                texture.needsUpdate = true;

            }

        }, function(){
          // console.log("loaded!");
        } );

    }

    for ( var i = 0; i < urls.length; ++ i ) {
        loadTexture( i );
    }

    scene.background = texture;

    // END TGA SKYMAP ----------------------------------------------------------




    // Controls
    controls = new THREE.OrbitControls( camera, renderer.domElement );
    controls.addEventListener( 'change', render );

    // Define geometry for visualising the spline
    var geometry = getWordGeometry( 'cab' );

    // Define a material to visualise the spline
    var material = new THREE.LineBasicMaterial({
        color: 0x111111,
    });

    // Visualise the spline on the scene
    var line = new THREE.Line(geometry, material);
    //scene.add(line); // <-- Uncomment to show the path

    plane = new Plane();

    // Fire the renderloop
    render();

    // Set the movePlane() function to fire every x miliseconds
    setInterval(movePlane, 50);
    

})();


document.addEventListener("keydown", function(e){
    switch(e.key) {
        case 's': plane.toggleSmoke(); break;
    }
}, false);
